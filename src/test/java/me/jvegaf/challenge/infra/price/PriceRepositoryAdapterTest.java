package me.jvegaf.challenge.infra.price;

// Generated by CodiumAI

import me.jvegaf.challenge.domain.price.Price;
import org.junit.Test;
import org.mockito.Mockito;

import java.math.BigDecimal;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;

import static org.junit.Assert.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class PriceRepositoryAdapterTest {
    // Should return a list of prices when given valid date, productId, and brandId
    @Test
    public void test_return_list_of_prices() {
        // Mock the dependencies
        JpaPriceRepository repository = mock(JpaPriceRepository.class);
        PriceEntityMapper mapper = mock(PriceEntityMapper.class);

        // Create test data
        Instant date = Instant.now();
        Long productId = 1L;
        Long brandId = 1L;
        List<PriceEntity> priceEntities = new ArrayList<>();
        priceEntities.add(new PriceEntity.Builder()
                .withId(1L)
                .withBrandId(brandId)
                .withStartDate(date.minus(1, ChronoUnit.DAYS))
                .withEndDate(date.plus(1, ChronoUnit.DAYS))
                .withProductId(productId)
                .withPriority(1L)
                .withPrice(BigDecimal.valueOf(10))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(1)
                .build());
        when(repository.findPriceByCriteria(date, productId, brandId)).thenReturn(priceEntities);

        // Create the adapter instance
        PriceRepositoryAdapter adapter = new PriceRepositoryAdapter(repository, mapper);

        // Call the method under test
        List<Price> prices = adapter.findPriceByCriteria(date, productId, brandId);

        // Verify the result
        assertEquals(priceEntities.size(), prices.size());
    }

    // Should return an empty list when no prices are found for given date, productId, and brandId
    @Test
    public void test_return_empty_list_when_no_prices_found() {
        // Mock the dependencies
        JpaPriceRepository repository = mock(JpaPriceRepository.class);
        PriceEntityMapper mapper = mock(PriceEntityMapper.class);

        // Create test data
        Instant date = Instant.now();
        Long productId = 1L;
        Long brandId = 1L;
        List<PriceEntity> priceEntities = new ArrayList<>();
        when(repository.findPriceByCriteria(date, productId, brandId)).thenReturn(priceEntities);

        // Create the adapter instance
        PriceRepositoryAdapter adapter = new PriceRepositoryAdapter(repository, mapper);

        // Call the method under test
        List<Price> prices = adapter.findPriceByCriteria(date, productId, brandId);

        // Verify the result
        assertTrue(prices.isEmpty());
    }

    // Should handle null productId parameter and return an empty list
    @Test
    public void test_handle_null_productId_parameter() {
        // Create mock objects
        JpaPriceRepository mockRepository = mock(JpaPriceRepository.class);
        PriceEntityMapper mockMapper = mock(PriceEntityMapper.class);

        // Create the PriceRepositoryAdapter instance with the mock objects
        PriceRepositoryAdapter adapter = new PriceRepositoryAdapter(mockRepository, mockMapper);

        // Set up the mock repository to return an empty list when findPriceByCriteria is called with null productId
        when(mockRepository.findPriceByCriteria(Mockito.any(), Mockito.isNull(), Mockito.any()))
                .thenReturn(Collections.emptyList());

        // Call the method under test with null productId
        List<Price> result = adapter.findPriceByCriteria(Instant.now(), null, 1L);

        // Verify that the mock repository method was called with the correct parameters
        Mockito.verify(mockRepository).findPriceByCriteria(Mockito.any(), Mockito.isNull(), Mockito.any());

        // Verify that the result is an empty list
        assertEquals(0, result.size());
    }

    // Should handle a single result found for given date, productId, and brandId
    @Test
    public void test_handle_single_result() {
        // Create mock objects
        JpaPriceRepository mockRepository = mock(JpaPriceRepository.class);
        PriceEntityMapper mockMapper = mock(PriceEntityMapper.class);

        // Create test data
        Instant date = Instant.now();
        Long productId = 1L;
        Long brandId = 1L;
        PriceEntity priceEntity = new PriceEntity.Builder()
                .withId(1L)
                .withBrandId(brandId)
                .withStartDate(date.minusSeconds(10))
                .withEndDate(date.plusSeconds(10))
                .withProductId(productId)
                .withPriority(1L)
                .withPrice(BigDecimal.valueOf(10.0))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(1)
                .build();
        List<PriceEntity> priceEntities = Collections.singletonList(priceEntity);
        Price price = new Price.Builder()
                .withId(1L)
                .withBrandId(brandId)
                .withStartDate(date.minusSeconds(10))
                .withEndDate(date.plusSeconds(10))
                .withProductId(productId)
                .withPriority(1L)
                .withPrice(BigDecimal.valueOf(10.0))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(1)
                .build();

        // Configure mock objects
        when(mockRepository.findPriceByCriteria(date, productId, brandId)).thenReturn(priceEntities);
        when(mockMapper.toDomain(priceEntity)).thenReturn(price);

        // Create instance of PriceRepositoryAdapter
        PriceRepositoryAdapter adapter = new PriceRepositoryAdapter(mockRepository, mockMapper);

        // Call the method under test
        List<Price> result = adapter.findPriceByCriteria(date, productId, brandId);

        // Verify the result
        assertEquals(1, result.size());
        assertEquals(price, result.get(0));

        // Verify the method calls on mock objects
        Mockito.verify(mockRepository).findPriceByCriteria(date, productId, brandId);
        Mockito.verify(mockMapper).toDomain(priceEntity);
    }

    // Should handle multiple results found for given date, productId, and brandId with same priority
    @Test
    public void test_handle_multiple_results_with_same_priority() {
        // Create mock objects
        JpaPriceRepository repository = mock(JpaPriceRepository.class);
        PriceEntityMapper mapper = mock(PriceEntityMapper.class);

        // Create test data
        Instant date = Instant.now();
        Long productId = 1L;
        Long brandId = 1L;

        // Create multiple PriceEntity objects with same priority
        PriceEntity priceEntity1 = new PriceEntity.Builder()
                .withId(1L)
                .withBrandId(brandId)
                .withStartDate(date.minusSeconds(10))
                .withEndDate(date.plusSeconds(10))
                .withProductId(productId)
                .withPriority(1L)
                .withPrice(BigDecimal.valueOf(10))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(1)
                .build();

        PriceEntity priceEntity2 = new PriceEntity.Builder()
                .withId(2L)
                .withBrandId(brandId)
                .withStartDate(date.minusSeconds(10))
                .withEndDate(date.plusSeconds(10))
                .withProductId(productId)
                .withPriority(1L)
                .withPrice(BigDecimal.valueOf(20))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(2)
                .build();

        List<PriceEntity> priceEntities = Arrays.asList(priceEntity1, priceEntity2);

        // Mock the repository method to return the test data
        when(repository.findPriceByCriteria(date, productId, brandId)).thenReturn(priceEntities);

        // Mock the mapper method to return the Price domain objects
        when(mapper.toDomain(priceEntity1)).thenReturn(new Price.Builder()
                .withId(priceEntity1.getId())
                .withBrandId(priceEntity1.getBrandId())
                .withStartDate(priceEntity1.getStartDate())
                .withEndDate(priceEntity1.getEndDate())
                .withProductId(priceEntity1.getProductId())
                .withPriority(priceEntity1.getPriority())
                .withPrice(priceEntity1.getPrice())
                .withCurrency(priceEntity1.getCurrency())
                .withPriceList(priceEntity1.getPriceList())
                .build());

        when(mapper.toDomain(priceEntity2)).thenReturn(new Price.Builder()
                .withId(priceEntity2.getId())
                .withBrandId(priceEntity2.getBrandId())
                .withStartDate(priceEntity2.getStartDate())
                .withEndDate(priceEntity2.getEndDate())
                .withProductId(priceEntity2.getProductId())
                .withPriority(priceEntity2.getPriority())
                .withPrice(priceEntity2.getPrice())
                .withCurrency(priceEntity2.getCurrency())
                .withPriceList(priceEntity2.getPriceList())
                .build());

        // Create an instance of PriceRepositoryAdapter with the mock objects
        PriceRepositoryAdapter adapter = new PriceRepositoryAdapter(repository, mapper);

        // Call the method under test
        List<Price> prices = adapter.findPriceByCriteria(date, productId, brandId);

        // Assert the results
        assertEquals(2, prices.size());
        assertEquals(priceEntity1.getId(), prices.get(0).getId());
        assertEquals(priceEntity2.getId(), prices.get(1).getId());
    }

    // Should log start and end of method execution
    @Test
    public void test_shouldLogStartAndEndOfMethodExecution() {
        // Create mock objects
        JpaPriceRepository mockRepository = mock(JpaPriceRepository.class);
        PriceEntityMapper mockMapper = mock(PriceEntityMapper.class);

        // Create test data
        Instant date = Instant.now();
        Long productId = 1L;
        Long brandId = 1L;

        // Create PriceEntity list
        List<PriceEntity> priceEntities = new ArrayList<>();
        PriceEntity priceEntity1 = new PriceEntity.Builder()
                .withId(1L)
                .withBrandId(1L)
                .withStartDate(date.minus(Duration.ofDays(1)))
                .withEndDate(date.plus(Duration.ofDays(1)))
                .withProductId(productId)
                .withPriority(1L)
                .withPrice(BigDecimal.valueOf(10.0))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(1)
                .build();
        priceEntities.add(priceEntity1);
        PriceEntity priceEntity2 = new PriceEntity.Builder()
                .withId(2L)
                .withBrandId(1L)
                .withStartDate(date.minus(Duration.ofDays(2)))
                .withEndDate(date.plus(Duration.ofDays(2)))
                .withProductId(productId)
                .withPriority(2L)
                .withPrice(BigDecimal.valueOf(20.0))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(2)
                .build();
        priceEntities.add(priceEntity2);

        // Create Price list
        List<Price> expectedPrices = new ArrayList<>();
        Price expectedPrice1 = new Price.Builder()
                .withId(1L)
                .withBrandId(1L)
                .withStartDate(date.minus(Duration.ofDays(1)))
                .withEndDate(date.plus(Duration.ofDays(1)))
                .withProductId(productId)
                .withPriority(1L)
                .withPrice(BigDecimal.valueOf(10.0))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(1)
                .build();
        expectedPrices.add(expectedPrice1);
        Price expectedPrice2 = new Price.Builder()
                .withId(2L)
                .withBrandId(1L)
                .withStartDate(date.minus(Duration.ofDays(2)))
                .withEndDate(date.plus(Duration.ofDays(2)))
                .withProductId(productId)
                .withPriority(2L)
                .withPrice(BigDecimal.valueOf(20.0))
                .withCurrency(Currency.getInstance("USD"))
                .withPriceList(2)
                .build();
        expectedPrices.add(expectedPrice2);

        // Mock the repository method
        when(mockRepository.findPriceByCriteria(date, productId, brandId)).thenReturn(priceEntities);

        // Mock the mapper method
        when(mockMapper.toDomain(priceEntity1)).thenReturn(expectedPrice1);
        when(mockMapper.toDomain(priceEntity2)).thenReturn(expectedPrice2);

        // Create the PriceRepositoryAdapter instance
        PriceRepositoryAdapter adapter = new PriceRepositoryAdapter(mockRepository, mockMapper);

        // Call the method under test
        List<Price> actualPrices = adapter.findPriceByCriteria(date, productId, brandId);

        // Verify the repository method was called with the correct parameters
        Mockito.verify(mockRepository).findPriceByCriteria(date, productId, brandId);

        // Verify the mapper method was called for each PriceEntity
        Mockito.verify(mockMapper).toDomain(priceEntity1);
        Mockito.verify(mockMapper).toDomain(priceEntity2);

        // Verify the expected prices match the actual prices
        assertEquals(expectedPrices, actualPrices);
    }

}
